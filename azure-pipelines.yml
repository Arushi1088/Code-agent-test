# Azure DevOps Pipeline for Self-Healing Development with Gemini CLI
# Simplified version for free tier compatibility

parameters:
- name: PatchInstruction
  displayName: 'Code Modification Instruction'
  type: string
  default: 'Fix the reported issue'
- name: WorkItemId
  displayName: 'Work Item ID to Update'
  type: string
  default: ''

variables:
- name: pythonVersion
  value: '3.10'
# Add these variables in Azure DevOps Pipeline Variables (keep them secret):
# - GITHUB_TOKEN: GitHub Personal Access Token for pushing changes
# - ADO_PAT: Azure DevOps Personal Access Token for work item updates

trigger:
  branches:
    include:
    - main
    - dev
  paths:
    exclude:
    - README.md
    - .gitignore

# Use Self-hosted agents (no parallelism limitations)
pool:
  name: SelfHosted

jobs:
- job: BuildAndTest
  displayName: 'Build, Test and Simulate Gemini Patching'
  steps:
  - script: |
      echo "=== PYTHON VERSION CHECK ==="
      python3 --version
      which python3
      echo "PATH=$PATH"
      echo "Current directory: $(pwd)"
      echo "User: $(whoami)"
      echo ""
      exit 0
    displayName: 'Check Python Version'

  - script: |
      echo "=== GEMINI CLI INSTALLATION ==="
      echo "Installing Gemini CLI..."
      # Note: Replace with actual Gemini CLI installation when available
      # curl -sSL https://download.gemini.ai/cli/install.sh | bash
      echo "Simulating Gemini CLI installation..."
      echo "‚úÖ Gemini CLI installed"
      echo ""
      
      echo "=== DEPENDENCY INSTALLATION ==="
      echo "Attempting pip upgrade..."
      python3 -m pip install --upgrade pip || echo "pip upgrade failed, continuing..."
      echo "Installing Azure CLI extensions..."
      az extension add --name azure-devops || echo "Azure DevOps extension already installed"
      echo "‚úÖ Dependencies installed"
      echo ""
      exit 0
    displayName: 'Install Gemini CLI and Dependencies'

  - script: |
      echo "=== SYNTAX CHECK ==="
      echo "Simulating: python -m py_compile github_agent_server.py"
      echo "Syntax check would run here"
      echo "‚úÖ Syntax check passed!"
      echo ""
      exit 0
    displayName: 'Simulate Run tests'

  - script: |
      echo "=== BUILD ARTIFACTS ==="
      echo "Simulating artifact creation..."
      ARTIFACT_DIR="${BUILD_ARTIFACTSTAGINGDIRECTORY:-/tmp/artifacts}"
      mkdir -p "$ARTIFACT_DIR"
      echo "Build completed at $(date)" > "$ARTIFACT_DIR/build-info.txt"
      echo "‚úÖ Build artifacts created in $ARTIFACT_DIR"
      echo ""
      exit 0
    displayName: 'Simulate Archive files'

  - script: |
      echo "=== GEMINI CLI PATCHING ==="
      echo "Patch Instruction: ${{ parameters.PatchInstruction }}"
      echo "Target Work Item: ${{ parameters.WorkItemId }}"
      echo "Current directory: $(pwd)"
      echo ""
      
      # Configure git for automated commits
      git config user.name "ADO Self-Healing Pipeline"
      git config user.email "build@dev.azure.com"
      
      echo "=== CREATING FEATURE BRANCH ==="
      BRANCH_NAME="feature/patch-$(Build.BuildId)"
      git checkout -b "$BRANCH_NAME"
      echo "Created branch: $BRANCH_NAME"
      
      echo "=== APPLYING PATCH ==="
      # TODO: Replace with real Gemini CLI when available
      # gemini patch --instruction "${{ parameters.PatchInstruction }}" --repo-path "$(Build.SourcesDirectory)"
      
      # For now, create a simple demonstration change
      echo "# Auto-applied patch: ${{ parameters.PatchInstruction }}" >> PATCH_LOG.md
      echo "Applied at: $(date)" >> PATCH_LOG.md
      echo "Build ID: $(Build.BuildId)" >> PATCH_LOG.md
      echo "" >> PATCH_LOG.md
      
      # Simulate code modification based on instruction
      if [[ "${{ parameters.PatchInstruction }}" == *"button"* ]]; then
        echo "Detected button-related instruction - would modify UI components"
        echo "// ${{ parameters.PatchInstruction }}" >> simulated_changes.js
      elif [[ "${{ parameters.PatchInstruction }}" == *"fix"* ]]; then
        echo "Detected fix instruction - would apply bug fixes"
        echo "# Fix applied: ${{ parameters.PatchInstruction }}" >> simulated_changes.py
      fi
      
      echo "‚úÖ Patch applied successfully"
      
      echo "=== COMMITTING CHANGES ==="
      git add .
      if git diff --staged --quiet; then
        echo "No changes to commit"
      else
        git commit -m "Auto-applied: ${{ parameters.PatchInstruction }} [Build $(Build.BuildId)]"
        echo "‚úÖ Changes committed"
        
        echo "=== PUSHING TO GITHUB ==="
        # Push to the personal repository that Azure DevOps monitors
        git push origin "$BRANCH_NAME"
        echo "‚úÖ Changes pushed to GitHub branch: $BRANCH_NAME"
        
        # Optionally merge back to main (for automatic integration)
        git checkout main
        git merge "$BRANCH_NAME"
        git push origin main
        echo "‚úÖ Changes merged to main branch"
      fi
      
      echo ""
      exit 0
    displayName: 'Apply Gemini Patch'
    condition: and(succeeded(), ne('${{ parameters.PatchInstruction }}', ''))
    env:
      # You'll need to add these as pipeline variables
      GITHUB_TOKEN: $(GITHUB_TOKEN)  # GitHub Personal Access Token

  - task: AzureCLI@2
    inputs:
      azureSubscription: 'DefaultAzureCredential'  # Update with your service connection name
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        echo "=== UPDATING AZURE DEVOPS WORK ITEM ==="
        echo "Work Item ID: ${{ parameters.WorkItemId }}"
        
        if [[ -n "${{ parameters.WorkItemId }}" ]]; then
          # Set Azure DevOps organization and project
          az devops configure --defaults organization=https://dev.azure.com/nayararushi0668 project="CODER TEST"
          
          # Update work item with progress
          az boards work-item update \
            --id ${{ parameters.WorkItemId }} \
            --fields System.State=Closed \
                     System.History="Automatically closed by self-healing pipeline. Applied patch: ${{ parameters.PatchInstruction }}. Build: $(Build.BuildId)" \
            --output table
          
          echo "‚úÖ Work item ${{ parameters.WorkItemId }} updated successfully"
        else
          echo "‚ö†Ô∏è No Work Item ID provided - skipping work item update"
        fi
    displayName: 'Update Azure DevOps Work Item'
    condition: and(succeeded(), ne('${{ parameters.WorkItemId }}', ''))
    env:
      AZURE_DEVOPS_EXT_PAT: $(ADO_PAT)  # Azure DevOps Personal Access Token

  - script: |
      echo "=== SELF-HEALING PIPELINE SUMMARY ==="
      echo "üöÄ Self-Healing Development Pipeline Completed"
      echo "üì¶ Build: Successful"
      echo "üîß Gemini Patching: ${{ parameters.PatchInstruction }}"
      echo "üìã Work Item: ${{ parameters.WorkItemId }}"
      echo "üîÑ Git Operations: Completed"
      echo "üìù Work Item Update: Completed"
      echo ""
      echo "‚úÖ Full self-healing cycle completed successfully!"
      echo ""
      echo "Next steps for production use:"
      echo "1. Replace Gemini CLI simulation with real installation:"
      echo "   curl -sSL https://download.gemini.ai/cli/install.sh | bash"
      echo "2. Set up pipeline variables: GITHUB_TOKEN, ADO_PAT"
      echo "3. Configure Azure service connection for work item updates"
      echo "4. Test with real work items and code modifications"
      echo ""
      exit 0
    displayName: 'Pipeline Summary'
